# [20200711双周赛](https://leetcode-cn.com/contest/biweekly-contest-30/)
## 目录
* [转变日期格式](#转变日期格式)
* [子数组和排序后的区间和](#子数组和排序后的区间和)
* [三次操作后最大值与最小值的最小差](#三次操作后最大值与最小值的最小差)
* [石子游戏IV](#石子游戏IV)
* [总结](#总结)

## 转变日期格式


### 示例

>
 
### 思路1


### 代码1

```Python
class Solution:
    def reformatDate(self, date: str) -> str:
        date = date.split()
        tmp = {"Jan":"01", "Feb":"02", "Mar":"03", "Apr":"04", "May":"05", "Jun":"06", "Jul":"07", "Aug":"08", "Sep":"09", "Oct":"10", "Nov":"11", "Dec":"12"}
        res = ""
        res += str(date[2]) + "-"
        res += tmp[date[1]] + "-"
        day = ""
        for ch in str(date[0]):
            if ch.isdigit():
                day += ch
            else:
                break
        if len(day) < 2:
            day = "0" + day
        res += day
        return res
```

## 子数组和排序后的区间和


### 示例

>

### 思路1


### 代码1

```Python
class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        tmp = []
        n = len(nums)
        for i in range(n):
            cur = 0
            for j in range(i, n):
                cur += nums[j]
                tmp.append(cur) 
        tmp.sort()    
        return sum(tmp[left-1:right])   
```

## 三次操作后最大值与最小值的最小差


### 示例

>

### 思路1


### 代码1

```Python
class Solution:
    def minDifference(self, nums) -> int:
        n = len(nums)
        if n <= 4:
            return 0
        res = float("inf")
        nums.sort()
        tmp = collections.defaultdict(int)
        for num in nums:
            tmp[num] += 1
        cnt = 0
        maxKey = -1
        for k, v in tmp.items():
            if v > cnt:
                cnt = max(cnt, v)
                maxKey = k
        tmp = list(set(tmp))
        tmp.sort()
        if cnt > 1:
            ind = tmp.index(maxKey)
            if n - cnt < 4:
                return 0
            if n - cnt == 4:
                try:
                    res = min(res, tmp[ind] - tmp[ind-1])
                except:
                    pass
                try:
                    res = min(res, tmp[ind+1] - tmp[ind])
                except:
                    pass
                return res
            start, end = -1, -1
            for i in range(n):
                if nums[i] == maxKey:
                    start = i
                    break
            for i in range(start+1, n):
                if nums[i] != maxKey:
                    end = i - 1
                    break
            if end == -1:
                end = n-1
            back = n-1-end
            gg = min(start, back)
            if gg < 3:
                if back < start:
                    return maxKey - nums[3-back]
                else:
                    return nums[-(1+3-start)] - maxKey
        if n == 5:
            for i in range(1, n):
                res = min(res, nums[i] - nums[i-1])
            return res
        if n == 6:
            return min(nums[2] - nums[0], nums[-1] - nums[-3])
        return min(nums[-4] - nums[0], nums[-1] - nums[3], nums[-2] - nums[2], nums[-3] - nums[1])
```

## 石子游戏IV


### 示例

>

### 思路1


### 代码1

```Python
class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        if int(n**0.5) == n**0.5:
            return True
        if n == 1:
            return True
        if n == 2:
            return False
        dp = [False] * (n+1)
        dp[1] = True
        dp[2] = False
        for i in range(3, n+1):
            if int(i**0.5) == i**0.5:
                dp[i] = True
                continue
            ind = 1
            while i - ind*ind > 0:
                if dp[i - ind*ind] == False:
                    dp[i] = True
                    break
                ind += 1
        return dp[n]
```

## 总结
除了第3题没AC，其余AC。比赛结束一分钟内通过了第3题，差点AK。不过这次题目很简单，就算AK了也只能拿600名左右，太菜了。  
目前全国排名 2424 ，全球排名 11421 。               
得分13/18，完成时间0:55:26，全国排名 647 / 2545，全球排名 1682 / 8174。   
1、0:04:52，**字符串**处理题，Python很好做。   
2、0:10:59，**暴力模拟**通过，比赛时想不出更优解。     
3、**暴力模拟**，要讨论的情况比较多，最后最后的return没考虑min()里的后两种情况，在比赛结束后一分钟内才通过，比较可惜。   
4、0:55:26，**石子游戏**一般使用**动态规划**做的，我这里算是用了**记忆化搜索**把n内所有的情况都讨论了，因为n的情况可以基于n前的情况决定。         